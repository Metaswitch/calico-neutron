--- a/neutron/agent/dhcp_agent.py
+++ b/neutron/agent/dhcp_agent.py
@@ -73,9 +73,24 @@
         self.cache = NetworkCache()
         self.root_helper = config.get_root_helper(self.conf)
         self.dhcp_driver_cls = importutils.import_class(self.conf.dhcp_driver)
+
+        # Work out if DHCP serving for bridged or routed VM interfaces.
+        try:
+            interface_driver = importutils.import_object(
+                self.conf.interface_driver, self.conf)
+            self.bridged = interface_driver.bridged()
+        except Exception as e:
+            msg = (_("Error importing interface driver '%(driver)s': "
+                   "%(inner)s") % {'driver': self.conf.interface_driver,
+                                   'inner': e})
+            LOG.error(msg)
+            raise SystemExit(msg)
+
         ctx = context.get_admin_context_without_session()
         self.plugin_rpc = DhcpPluginApi(topics.PLUGIN,
-                                        ctx, self.conf.use_namespaces)
+                                        ctx,
+                                        self.bridged and
+                                        self.conf.use_namespaces)
         # create dhcp dir to store dhcp info
         dhcp_dir = os.path.dirname("/%s/dhcp/" % self.conf.state_path)
         if not os.path.isdir(dhcp_dir):
@@ -91,7 +106,8 @@
                 self.root_helper
             )
             for net_id in existing_networks:
-                net = dhcp.NetModel(self.conf.use_namespaces,
+                net = dhcp.NetModel(self.bridged and
+                                    self.conf.use_namespaces,
                                     {"id": net_id,
                                      "subnets": [],
                                      "ports": []})
@@ -217,7 +233,8 @@
         for subnet in network.subnets:
             if subnet.enable_dhcp and subnet.ip_version == 4:
                 if self.call_driver('enable', network):
-                    if self.conf.use_namespaces and enable_metadata:
+                    if (self.bridged and
+                        self.conf.use_namespaces and enable_metadata):
                         self.enable_isolated_metadata_proxy(network)
                         enable_metadata = False  # Don't trigger twice
                     self.cache.put(network)
@@ -227,7 +244,8 @@
         """Disable DHCP for a network known to the agent."""
         network = self.cache.get_network_by_id(network_id)
         if network:
-            if (self.conf.use_namespaces and
+            if (self.bridged and
+                self.conf.use_namespaces and
                 self.conf.enable_isolated_metadata):
                 # NOTE(jschwarz): In the case where a network is deleted, all
                 # the subnets and ports are deleted before this function is
--- a/neutron/agent/linux/dhcp.py
+++ b/neutron/agent/linux/dhcp.py
@@ -322,21 +322,49 @@
             self.NEUTRON_NETWORK_ID_KEY: self.network.id,
         }
 
-        cmd = [
-            'dnsmasq',
-            '--no-hosts',
-            '--no-resolv',
-            '--strict-order',
-            '--bind-interfaces',
-            '--interface=%s' % self.interface_name,
-            '--except-interface=lo',
-            '--pid-file=%s' % self.get_conf_file_name(
-                'pid', ensure_conf_dir=True),
-            '--dhcp-hostsfile=%s' % self._output_hosts_file(),
-            '--addn-hosts=%s' % self._output_addn_hosts_file(),
-            '--dhcp-optsfile=%s' % self._output_opts_file(),
-            '--leasefile-ro',
-        ]
+        if self.device_manager.bridged():
+            cmd = [
+                'dnsmasq',
+                '--no-hosts',
+                '--no-resolv',
+                '--strict-order',
+                '--bind-interfaces',
+                '--interface=%s' % self.interface_name,
+                '--except-interface=lo',
+                '--pid-file=%s' % self.get_conf_file_name(
+                 'pid', ensure_conf_dir=True),
+                '--dhcp-hostsfile=%s' % self._output_hosts_file(),
+                '--addn-hosts=%s' % self._output_addn_hosts_file(),
+                '--dhcp-optsfile=%s' % self._output_opts_file(),
+                '--leasefile-ro',
+                ]
+        else:
+            # When the DHCP port and VM TAP interfaces are not
+            # bridged, we change the dnsmasq invocation as follows.
+            #   --interface=tap* # to listen on all TAP interfaces
+            #   --bind-dynamic instead of --bind-interfaces, to
+            #     automatically start listening on new TAP
+            #     interfaces as they appear
+            #   --bridge-interface=%s,tap* # to treat all TAP
+            #     interfaces as aliases of the DHCP port.
+            cmd = [
+                'dnsmasq',
+                '--no-hosts',
+                '--no-resolv',
+                '--strict-order',
+                '--bind-dynamic',
+                '--interface=%s' % self.interface_name,
+                '--interface=tap*',
+                '--bridge-interface=%s,tap*' % self.interface_name,
+                '--except-interface=lo',
+                '--pid-file=%s' % self.get_conf_file_name(
+                    'pid', ensure_conf_dir=True),
+                '--dhcp-hostsfile=%s' % self._output_hosts_file(),
+                '--addn-hosts=%s' % self._output_addn_hosts_file(),
+                '--dhcp-optsfile=%s' % self._output_opts_file(),
+                '--leasefile-ro',
+                '--enable-ra',
+                ]
 
         possible_leases = 0
         for i, subnet in enumerate(self.network.subnets):
@@ -345,10 +373,16 @@
                 continue
             if subnet.ip_version == 4:
                 mode = 'static'
-            else:
+            elif self.device_manager.bridged():
                 # TODO(mark): how do we indicate other options
                 # ra-only, slaac, ra-nameservers, and ra-stateless.
                 mode = 'static'
+            else:
+                # For routed IPv6 networking specify 'off-link' flag
+                # to Dnsmasq.  This results in VM adding a default
+                # route to the link-local address of the TAP interface
+                # on the compute host.
+                mode = 'static,off-link'
             if self.version >= self.MINIMUM_VERSION:
                 set_tag = 'set:'
             else:
@@ -706,6 +740,7 @@
         try:
             self.driver = importutils.import_object(
                 conf.interface_driver, conf)
+            self.driver_bridged = bool(self.driver.bridged())
         except Exception as e:
             msg = (_("Error importing interface driver '%(driver)s': "
                    "%(inner)s") % {'driver': conf.interface_driver,
@@ -713,6 +748,9 @@
             LOG.error(msg)
             raise SystemExit(msg)
 
+    def bridged(self):
+        return self.driver_bridged
+
     def get_interface_name(self, network, port):
         """Return interface(device) name for use by the DHCP process."""
         return self.driver.get_device_name(port)
@@ -779,23 +817,30 @@
         for port in network.ports:
             port_device_id = getattr(port, 'device_id', None)
             if port_device_id == device_id:
-                port_fixed_ips = []
-                for fixed_ip in port.fixed_ips:
-                    port_fixed_ips.append({'subnet_id': fixed_ip.subnet_id,
-                                           'ip_address': fixed_ip.ip_address})
-                    if fixed_ip.subnet_id in dhcp_enabled_subnet_ids:
-                        dhcp_enabled_subnet_ids.remove(fixed_ip.subnet_id)
-
-                # If there are dhcp_enabled_subnet_ids here that means that
-                # we need to add those to the port and call update.
-                if dhcp_enabled_subnet_ids:
-                    port_fixed_ips.extend(
-                        [dict(subnet_id=s) for s in dhcp_enabled_subnet_ids])
-                    dhcp_port = self.plugin.update_dhcp_port(
-                        port.id, {'port': {'fixed_ips': port_fixed_ips}})
-                    if not dhcp_port:
-                        raise exceptions.Conflict()
+                if self.driver_bridged:
+                    port_fixed_ips = []
+                    for fixed_ip in port.fixed_ips:
+                        port_fixed_ips.append({'subnet_id': fixed_ip.subnet_id,
+                                               'ip_address': fixed_ip.ip_address})
+                        if fixed_ip.subnet_id in dhcp_enabled_subnet_ids:
+                            dhcp_enabled_subnet_ids.remove(fixed_ip.subnet_id)
+
+                    # If there are dhcp_enabled_subnet_ids here that means that
+                    # we need to add those to the port and call update.
+                    if dhcp_enabled_subnet_ids:
+                        port_fixed_ips.extend(
+                            [dict(subnet_id=s) for s in dhcp_enabled_subnet_ids])
+                        dhcp_port = self.plugin.update_dhcp_port(
+                            port.id, {'port': {'fixed_ips': port_fixed_ips}})
+                        if not dhcp_port:
+                            raise exceptions.Conflict()
+                    else:
+                        dhcp_port = port
                 else:
+                    # When the DHCP port and VM TAP interfaces are not
+                    # bridged, we don't allocate a unique IP address
+                    # for the DHCP port.
+                    LOG.debug("port.fixed_ips = %s" % port.fixed_ips)
                     dhcp_port = port
                 # break since we found port that matches device_id
                 break
@@ -805,13 +850,21 @@
             LOG.debug(_('DHCP port %(device_id)s on network %(network_id)s'
                         ' does not yet exist.'), {'device_id': device_id,
                                                   'network_id': network.id})
+
+            # When the DHCP port and VM TAP interfaces are not
+            # bridged, we don't allocate a unique IP address for the
+            # DHCP port.
+            port_fixed_ips = []
+            if self.driver_bridged:
+                port_fixed_ips=[dict(subnet_id=s) for s in dhcp_enabled_subnet_ids]
+
             port_dict = dict(
                 name='',
                 admin_state_up=True,
                 device_id=device_id,
                 network_id=network.id,
                 tenant_id=network.tenant_id,
-                fixed_ips=[dict(subnet_id=s) for s in dhcp_enabled_subnet_ids])
+                fixed_ips=port_fixed_ips)
             dhcp_port = self.plugin.create_dhcp_port({'port': port_dict})
 
         if not dhcp_port:
@@ -855,27 +908,50 @@
             ip_cidr = '%s/%s' % (fixed_ip.ip_address, net.prefixlen)
             ip_cidrs.append(ip_cidr)
 
-        if (self.conf.enable_isolated_metadata and
+        if not self.driver_bridged:
+            # When the DHCP port and VM TAP interfaces are not
+            # bridged, assign the subnet's gateway IP address to the
+            # DHCP port.
+            LOG.debug("ip_cidrs = %s" % ip_cidrs)
+
+            for i, subnet in enumerate(network.subnets):
+                if not subnet.enable_dhcp:
+                    continue
+
+                gateway = subnet.gateway_ip
+                for hr in subnet.host_routes:
+                    if hr.destination == "0.0.0.0/0":
+                        gateway = hr.nexthop
+
+                if gateway:
+                    net = netaddr.IPNetwork(subnet.cidr)
+                    ip_cidrs.append('%s/%s' % (gateway, net.prefixlen))
+
+        if (self.driver_bridged and
+            self.conf.enable_isolated_metadata and
             self.conf.use_namespaces):
             ip_cidrs.append(METADATA_DEFAULT_CIDR)
 
+        LOG.debug("ip_cidrs = %s" % ip_cidrs)
         self.driver.init_l3(interface_name, ip_cidrs,
                             namespace=network.namespace)
 
         # ensure that the dhcp interface is first in the list
-        if network.namespace is None:
+        if self.driver_bridged and network.namespace is None:
             device = ip_lib.IPDevice(interface_name,
                                      self.root_helper)
             device.route.pullup_route(interface_name)
 
-        if self.conf.use_namespaces:
+        if (self.driver_bridged and
+            self.conf.use_namespaces):
             self._set_default_route(network, interface_name)
 
         return interface_name
 
     def update(self, network, device_name):
         """Update device settings for the network's DHCP on this host."""
-        if self.conf.use_namespaces:
+        if (self.driver_bridged and
+            self.conf.use_namespaces):
             self._set_default_route(network, device_name)
 
     def destroy(self, network, device_name):
--- a/neutron/agent/linux/interface.py
+++ b/neutron/agent/linux/interface.py
@@ -141,6 +141,13 @@
             LOG.exception(_("Failed deleting egress connection state of"
                             " floatingip %s"), ip_str)
 
+    def bridged(self):
+        # Interfaces are normally plugged into some kind of bridge;
+        # the only exception is RoutedInterfaceDriver.  Hence return
+        # True by default here and override that in
+        # RoutedInterfaceDriver.
+        return True
+
     def check_bridge_exists(self, bridge):
         if not ip_lib.device_exists(bridge):
             raise exceptions.BridgeDoesNotExist(bridge=bridge)
@@ -411,6 +418,52 @@
         device = ip_lib.IPDevice(device_name, self.root_helper, namespace)
         try:
             device.link.delete()
+            LOG.debug(_("Unplugged interface '%s'"), device_name)
+        except RuntimeError:
+            LOG.error(_("Failed unplugging interface '%s'"),
+                      device_name)
+
+
+class RoutedInterfaceDriver(LinuxInterfaceDriver):
+    """Driver for DHCP service for routed virtual interfaces."""
+
+    DEV_NAME_PREFIX = 'ns-'
+
+    def bridged(self):
+        # Routed interfaces are not plugged into an L2 bridge.
+        return False
+
+    def plug(self, network_id, port_id, device_name, mac_address,
+             bridge=None, namespace=None, prefix=None):
+        """Plugin the interface."""
+        LOG.warning("RoutedInterfaceDriver::plug(%s, %s, %s, %s, %s, %s, %s)" %
+                    (network_id, port_id, device_name, mac_address,
+                     bridge, namespace, prefix));
+        if not ip_lib.device_exists(device_name,
+                                    self.root_helper,
+                                    namespace=namespace):
+            ip = ip_lib.IPWrapper(self.root_helper)
+
+            # Create ns_veth in a namespace if one is configured.
+            ns_veth = ip.add_dummy(device_name, namespace2=namespace)
+            ns_veth.link.set_address(mac_address)
+
+            if self.conf.network_device_mtu:
+                ns_veth.link.set_mtu(self.conf.network_device_mtu)
+
+            ns_veth.link.set_up()
+
+        else:
+            LOG.info(_("Device %s already exists"), device_name)
+
+    def unplug(self, device_name, bridge=None, namespace=None, prefix=None):
+        """Unplug the interface."""
+        LOG.warning("BridgeInterfaceDriver::unplug(%s, %s, %s, %s)" %
+                    (device_name, mac_address,
+                     bridge, namespace, prefix));
+        device = ip_lib.IPDevice(device_name, self.root_helper, namespace)
+        try:
+            device.link.delete()
             LOG.debug(_("Unplugged interface '%s'"), device_name)
         except RuntimeError:
             LOG.error(_("Failed unplugging interface '%s'"),
--- a/neutron/agent/linux/ip_lib.py
+++ b/neutron/agent/linux/ip_lib.py
@@ -132,6 +132,19 @@
         return (IPDevice(name1, self.root_helper, self.namespace),
                 IPDevice(name2, self.root_helper, namespace2))
 
+    def add_dummy(self, name1, namespace2=None):
+        args = ['add', name1, 'type', 'dummy']
+
+        if namespace2 is None:
+            namespace2 = self.namespace
+        else:
+            self.ensure_namespace(namespace2)
+            args += ['netns', namespace2]
+
+        self._as_root('', 'link', tuple(args))
+
+        return IPDevice(name1, self.root_helper, self.namespace)
+
     def ensure_namespace(self, name):
         if not self.netns.exists(name):
             ip = self.netns.add(name)
--- a/neutron/agent/metadata/agent.py
+++ b/neutron/agent/metadata/agent.py
@@ -146,9 +146,13 @@
         """
         qclient = self._get_neutron_client()
 
-        all_ports = qclient.list_ports(
-            network_id=networks,
-            fixed_ips=['ip_address=%s' % remote_address])['ports']
+        if networks:
+            all_ports = qclient.list_ports(
+                network_id=networks,
+                fixed_ips=['ip_address=%s' % remote_address])['ports']
+        else:
+            all_ports = qclient.list_ports(
+                fixed_ips=['ip_address=%s' % remote_address])['ports']
         self.auth_info = qclient.get_auth_info()
         return all_ports
 
@@ -165,8 +169,7 @@
         elif router_id:
             networks = self._get_router_networks(router_id)
         else:
-            raise TypeError(_("Either one of parameter network_id or router_id"
-                              " must be passed to _get_ports method."))
+            networks = None
 
         return self._get_ports_for_remote_address(remote_address, networks)
 
--- a/neutron/agent/metadata/namespace_proxy.py
+++ b/neutron/agent/metadata/namespace_proxy.py
@@ -55,12 +55,14 @@
     accessible within the isolated tenant context.
     """
 
-    def __init__(self, network_id=None, router_id=None):
+    def __init__(self, network_id=None, router_id=None, flat=None):
         self.network_id = network_id
         self.router_id = router_id
+        self.flat = flat
 
-        if network_id is None and router_id is None:
-            msg = _('network_id and router_id are None. One must be provided.')
+        if network_id is None and router_id is None and flat is None:
+            msg = _('network_id, router_id and flat are None. One must be '
+                    'provided.')
             raise ValueError(msg)
 
     @webob.dec.wsgify(RequestClass=webob.Request)
@@ -86,7 +88,7 @@
 
         if self.router_id:
             headers['X-Neutron-Router-ID'] = self.router_id
-        else:
+        elif self.network_id:
             headers['X-Neutron-Network-ID'] = self.network_id
 
         url = urlparse.urlunsplit((
@@ -127,17 +129,20 @@
 
 
 class ProxyDaemon(daemon.Daemon):
-    def __init__(self, pidfile, port, network_id=None, router_id=None):
-        uuid = network_id or router_id
-        super(ProxyDaemon, self).__init__(pidfile, uuid=uuid)
+    def __init__(self, pidfile, port, network_id=None, router_id=None,
+                 flat=None):
+        this_uuid = network_id or router_id or flat
+        super(ProxyDaemon, self).__init__(pidfile, uuid=this_uuid)
         self.network_id = network_id
         self.router_id = router_id
+        self.flat = flat
         self.port = port
 
     def run(self):
         handler = NetworkMetadataProxyHandler(
             self.network_id,
-            self.router_id)
+            self.router_id,
+            self.flat)
         proxy = wsgi.Server('neutron-network-metadata-proxy')
         proxy.start(handler, self.port)
         proxy.wait()
@@ -152,6 +157,10 @@
         cfg.StrOpt('router_id',
                    help=_('Router that will have connected instances\' '
                           'metadata proxied.')),
+        cfg.StrOpt('flat',
+                   help=_('Flat networking is being used: neither the network '
+                          'nor the router ID is provided. This argument takes '
+                          'a UUID to identify the instance.')),
         cfg.StrOpt('pid_file',
                    help=_('Location of pid file of this process.')),
         cfg.BoolOpt('daemonize',
@@ -175,7 +184,8 @@
     proxy = ProxyDaemon(cfg.CONF.pid_file,
                         cfg.CONF.metadata_port,
                         network_id=cfg.CONF.network_id,
-                        router_id=cfg.CONF.router_id)
+                        router_id=cfg.CONF.router_id,
+                        flat=cfg.CONF.flat)
 
     if cfg.CONF.daemonize:
         proxy.start()
--- a/neutron/extensions/portbindings.py
+++ b/neutron/extensions/portbindings.py
@@ -60,11 +60,13 @@
 VIF_TYPE_MIDONET = 'midonet'
 VIF_TYPE_MLNX_DIRECT = 'mlnx_direct'
 VIF_TYPE_MLNX_HOSTDEV = 'hostdev'
+VIF_TYPE_ROUTED = 'routed'
 VIF_TYPE_OTHER = 'other'
 VIF_TYPES = [VIF_TYPE_UNBOUND, VIF_TYPE_BINDING_FAILED, VIF_TYPE_OVS,
              VIF_TYPE_IVS, VIF_TYPE_BRIDGE, VIF_TYPE_802_QBG,
              VIF_TYPE_802_QBH, VIF_TYPE_HYPERV, VIF_TYPE_MIDONET,
-             VIF_TYPE_MLNX_DIRECT, VIF_TYPE_MLNX_HOSTDEV, VIF_TYPE_OTHER]
+             VIF_TYPE_MLNX_DIRECT, VIF_TYPE_MLNX_HOSTDEV, VIF_TYPE_ROUTED,
+             VIF_TYPE_OTHER]
 
 VNIC_NORMAL = 'normal'
 VNIC_DIRECT = 'direct'
--- /dev/null
+++ b/neutron/plugins/ml2/drivers/mech_calico.py
@@ -0,0 +1,732 @@
+# -*- coding: utf-8 -*-
+#
+# Copyright (c) 2014 Metaswitch Networks
+# Copyright (c) 2013 OpenStack Foundation
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+
+#*****************************************************************************#
+#* Calico/OpenStack Plugin                                                   *#
+#*                                                                           *#
+#* This module is the OpenStack-specific implementation of the Plugin        *#
+#* component of the new Calico architecture (described by the "Felix, the    *#
+#* Calico Plugin and the Calico ACL Manager" wiki page at                    *#
+#* https://github.com/Metaswitch/calico-docs/wiki).                          *#
+#*                                                                           *#
+#* It is implemented as a Neutron/ML2 mechanism driver.                      *#
+#*****************************************************************************#
+
+from neutron.common import constants
+from neutron.extensions import portbindings
+from neutron.openstack.common import log
+from neutron.plugins.ml2 import driver_api as api
+from neutron.plugins.ml2.drivers import mech_agent
+import eventlet
+from eventlet.green import zmq
+import json
+import time
+from neutron import context
+from neutron import manager
+
+LOG = log.getLogger(__name__)
+
+#*****************************************************************************#
+#* TCP port numbers used by the 0MQ sockets that connect the Calico plugin,  *#
+#* Felix and ACL Manager components, as shown by the following diagram.      *#
+#*                                                                           *#
+#*                                                                           *#
+#*                ROUTER #1 +------------+ #3 ROUTER                         *#
+#*          ,-------------->|            |<-------------------.              *#
+#*          |               |   Plugin   |                    |              *#
+#*          |   ,-----------|            |<---------------.   |              *#
+#*          |   |     REQ   +------------+ #4 PUB         |   |              *#
+#*          |   |                                         |   |              *#
+#*          |   |                                         |   |              *#
+#*          |   |                                         |   |              *#
+#*          |   |                                         |   |              *#
+#*          |   |                                         |   |              *#
+#*          |   |                                         |   |              *#
+#*          |   |                                         |   |              *#
+#*      REQ |   | REP                                 SUB |   | REQ          *#
+#*          |   V #2                                      |   |              *#
+#*     +------------+ SUB                  PUB #6 +-----------------+        *#
+#*     |            |---------------------------->|                 |        *#
+#*     |   Felix    |                             |   ACL Manager   |        *#
+#*     |            |---------------------------->|                 |        *#
+#*     +------------+ REQ               ROUTER #5 +-----------------+        *#
+#*                                                                           *#
+#*                                                                           *#
+#*  #1: tcp://controller:PLUGIN_ENDPOINT_PORT                                *#
+#*                                                                           *#
+#*  #2: tcp://felix_host:FELIX_ENDPOINT_PORT                                 *#
+#*                                                                           *#
+#*  #3: tcp://controller:PLUGIN_ACLGET_PORT                                  *#
+#*                                                                           *#
+#*  #4: tcp://controller:PLUGIN_ACLPUB_PORT                                  *#
+#*                                                                           *#
+#*  #5: tcp://acl_host:MANAGER_ACLGET_PORT                                   *#
+#*                                                                           *#
+#*  #6: tcp://acl_host:MANAGER_ACLPUB_PORT                                   *#
+#*                                                                           *#
+#*****************************************************************************#
+PLUGIN_ENDPOINT_PORT = 9901
+FELIX_ENDPOINT_PORT = 9902
+PLUGIN_ACLGET_PORT = 9903
+PLUGIN_ACLPUB_PORT = 9904
+
+#*****************************************************************************#
+#* Time (ms) to allow for Felix to send us an ENDPOINT* response.            *#
+#*****************************************************************************#
+ENDPOINT_RESPONSE_TIMEOUT = 2000
+
+#*****************************************************************************#
+#* Time (ms) to allow for Felix to send us a HEARTBEAT response.             *#
+#*****************************************************************************#
+HEARTBEAT_RESPONSE_TIMEOUT = 2000
+
+#*****************************************************************************#
+#* Time between heartbeats, in seconds.                                      *#
+#*****************************************************************************#
+HEARTBEAT_SEND_INTERVAL_SECS = 10
+
+#*****************************************************************************#
+#* An OpenStack agent type name for Felix, the Calico agent component in the *#
+#* new architecture.                                                         *#
+#*****************************************************************************#
+AGENT_TYPE_FELIX = 'Felix (Calico agent)'
+
+
+class CalicoMechanismDriver(mech_agent.SimpleAgentMechanismDriverBase):
+    """Neutron/ML2 mechanism driver for Project Calico.
+
+    CalicoMechanismDriver communicates information about endpoints and security
+    configuration, over the Endpoint and Network APIs respectively, to the
+    other components of the Calico architecture; namely to the Felix instances
+    running on each compute host, and to one or more ACL Managers.
+    """
+
+    def __init__(self):
+        super(CalicoMechanismDriver, self).__init__(
+            constants.AGENT_TYPE_DHCP,
+            portbindings.VIF_TYPE_ROUTED,
+            {portbindings.CAP_PORT_FILTER: True})
+
+        #*********************************************************************#
+        #* Initialize dictionary mapping Felix hostnames to corresponding    *#
+        #* REQ sockets.                                                      *#
+        #*********************************************************************#
+        self.felix_peer_sockets = {}
+
+        #*********************************************************************#
+        #* Initialize fields for the database object and context.  We will   *#
+        #* initialize these properly when we first need them.                *#
+        #*********************************************************************#
+        self.db = None
+        self.db_context = None
+
+        #*********************************************************************#
+        #* Open Felix- and ACL Manager-facing sockets.                       *#
+        #*********************************************************************#
+        self.open_sockets()
+
+    def _get_db_context(self):
+        if not self.db_context:
+            self.db_context = context.get_admin_context()
+            LOG.info("ctxt = %s" % self.db_context)
+        if not self.db:
+            self.db = manager.NeutronManager.get_plugin()
+            LOG.info("db = %s" % self.db)
+
+            #*****************************************************************#
+            #* Installer a notifier proxy in order to catch security group   *#
+            #* changes, if we haven't already.                               *#
+            #*****************************************************************#
+            if self.db.notifier.__class__ != CalicoNotifierProxy:
+                self.db.notifier = CalicoNotifierProxy(self.db.notifier, self)
+
+    def check_segment_for_agent(self, segment, agent):
+        LOG.debug("Checking segment %s with agent %s" % (segment, agent))
+        if segment[api.NETWORK_TYPE] in ['local', 'flat']:
+            return True
+        else:
+            return False
+
+    def open_sockets(self):
+        self.zmq_context = zmq.Context()
+        LOG.warn("pyzmq version is %s" % zmq.pyzmq_version())
+
+        #*********************************************************************#
+        #* Create ROUTER socket for Felix instances to connect to.           *#
+        #*********************************************************************#
+        self.felix_router_socket = self.zmq_context.socket(zmq.ROUTER)
+        self.felix_router_socket.bind("tcp://*:%s" % PLUGIN_ENDPOINT_PORT)
+
+        #*********************************************************************#
+        #* Create ROUTER socket for ACL Manager(s) to connect to.            *#
+        #*********************************************************************#
+        self.acl_get_socket = self.zmq_context.socket(zmq.ROUTER)
+        self.acl_get_socket.bind("tcp://*:%s" % PLUGIN_ACLGET_PORT)
+
+        #*********************************************************************#
+        #* Create PUB socket for sending ACL updates to ACL Manager(s).      *#
+        #*********************************************************************#
+        self.acl_pub_socket = self.zmq_context.socket(zmq.PUB)
+        self.acl_pub_socket.bind("tcp://*:%s" % PLUGIN_ACLPUB_PORT)
+
+        #*********************************************************************#
+        #* Spawn green thread for handling RESYNCSTATE requests on the       *#
+        #* Felix-ROUTER socket.                                              *#
+        #*********************************************************************#
+        eventlet.spawn_n(self.felix_router_thread)
+
+        #*********************************************************************#
+        #* Spawn green thread for handling GETGROUPS and GETRULES requests   *#
+        #* on the ACL-GET socket.                                            *#
+        #*********************************************************************#
+        eventlet.spawn_n(self.acl_get_thread)
+
+        LOG.info("Started threads")
+
+    def felix_router_thread(self):
+
+        while True:
+
+            LOG.info("Felix-ROUTER: wait to receive next message")
+            try:
+                #*************************************************************#
+                #* Receive the next message on the ROUTER socket for Felix   *#
+                #* instances.  This may block, but that's OK because all     *#
+                #* other green threads in the Neutron server process can run *#
+                #* in the meantime.                                          *#
+                #*************************************************************#
+                message = self.felix_router_socket.recv_multipart()
+
+                #*************************************************************#
+                #* Every message on this socket should be multipart with 3   *#
+                #* parts, of which the second part is always empty.  (Why?)  *#
+                #*************************************************************#
+                assert (len(message) == 3)
+                assert not message[1]
+
+                #*************************************************************#
+                #* The first part is the connection identity, and the third  *#
+                #* is the message content.                                   *#
+                #*************************************************************#
+                peer = message[0]
+                rq = json.loads(message[2].decode('utf-8'))
+                LOG.info("Felix-ROUTER RX [%s] %s" % (peer, rq))
+
+                if rq['type'] == 'RESYNCSTATE':
+                    #*********************************************************#
+                    #* It's a RESYNCSTATE request.                           *#
+                    #*********************************************************#
+                    LOG.info("RESYNCSTATE request")
+
+                    #*********************************************************#
+                    #* Set up access to the Neutron database, if we haven't  *#
+                    #* already.                                              *#
+                    #*********************************************************#
+                    self._get_db_context()
+
+                    #*********************************************************#
+                    #* Get a list of all ports on the Felix host.            *#
+                    #* Unfortunately it isn't possible to use                *#
+                    #* 'binding:host_id' as a query filter, so we filter the *#
+                    #* results ourselves instead.                            *#
+                    #*********************************************************#
+                    LOG.info("Query Neutron DB...")
+                    ports = []
+                    for port in self.db.get_ports(self.db_context):
+                        if (port['binding:host_id'] == rq['hostname'] and
+                            self._port_is_endpoint_port(port)):
+                            ports.append(port)
+
+                    resync_rsp = {'type': 'RESYNCSTATE',
+                                  'endpoint_count': len(ports),
+                                  'rc': 'SUCCESS',
+                                  'message': 'Здра́вствуйте!'}
+
+                    #*********************************************************#
+                    #* Send the prepared response.                           *#
+                    #*********************************************************#
+                    LOG.info("Sending response: %s" % resync_rsp)
+                    self.felix_router_socket.send_multipart(
+                        [peer,
+                         '',
+                         json.dumps(resync_rsp).encode('utf-8')])
+
+                    #*********************************************************#
+                    #* If we don't already have a REQ socket to this Felix,  *#
+                    #* create that now.                                      *#
+                    #*********************************************************#
+                    self._ensure_socket_to_felix_peer(rq['hostname'])
+
+                    #*********************************************************#
+                    #* Now also send an ENDPOINTCREATED request to the Felix *#
+                    #* instance, for each port.                              *#
+                    #*********************************************************#
+                    for port in ports:
+                        self.send_endpoint(rq['hostname'],
+                                           rq['resync_id'],
+                                           port,
+                                           'CREATED')
+
+                elif rq['type'] == 'HEARTBEAT':
+                    #*********************************************************#
+                    #* It's a heartbeat.  Send the same back.                *#
+                    #*********************************************************#
+                    LOG.info("HEARTBEAT")
+                    self.felix_router_socket.send_multipart(
+                        peer,
+                        '',
+                        json.dumps(rq).encode('utf-8'))
+
+                else:
+                    #*********************************************************#
+                    #* It's something unexpected.  Log a warning, but send   *#
+                    #* it back anyway.                                       *#
+                    #*********************************************************#
+                    LOG.warn("Unexpected request type")
+                    self.felix_router_socket.send_multipart(
+                        peer,
+                        '',
+                        json.dumps(rq).encode('utf-8'))
+            except:
+                LOG.exception("Exception in Felix-facing ROUTER socket thread")
+
+    def _ensure_socket_to_felix_peer(self, hostname):
+        if not hostname in self.felix_peer_sockets:
+            LOG.info("Create new socket for %s" % hostname)
+            try:
+                sock = self.zmq_context.socket(zmq.REQ)
+                sock.setsockopt(zmq.LINGER, 0)
+                sock.connect("tcp://%s:%s" % (hostname, FELIX_ENDPOINT_PORT))
+                self.felix_peer_sockets[hostname] = sock
+                self.db.create_or_update_agent(self.db_context,
+                                               {'agent_type': AGENT_TYPE_FELIX,
+                                                'binary': '',
+                                                'host': hostname,
+                                                'topic': constants.L2_AGENT_TOPIC,
+                                                'start_flag': True})
+                eventlet.spawn_n(self.felix_heartbeat_thread, hostname)
+            except:
+                LOG.exception("Peer is not actually available")
+
+    def _get_socket_for_felix_peer(self, hostname):
+        if hostname in self.felix_peer_sockets:
+            return self.felix_peer_sockets[hostname]
+        else:
+            return None
+
+    def _clear_socket_to_felix_peer(self, hostname):
+        if hostname in self.felix_peer_sockets:
+            self.felix_peer_sockets[hostname].close()
+            del self.felix_peer_sockets[hostname]
+
+    def _port_is_endpoint_port(self, port):
+
+        #*********************************************************************#
+        #* Return True if port is a VM port.                                 *#
+        #*********************************************************************#
+        if port['device_owner'].startswith('compute:'):
+            return True
+
+        #*********************************************************************#
+        #* Otherwise log and return False.                                   *#
+        #*********************************************************************#
+        LOG.debug("Not a VM port: %s" % port)
+        return False
+
+    def send_endpoint(self, hostname, resync_id, port, op):
+        LOG.info("Send ENDPOINT%s to %s for %s" % (op, hostname, port))
+
+        #*********************************************************************#
+        #* Get the socket that we should send on to the Felix on this        *#
+        #* hostname.  If there is no such socket, bail out.                  *#
+        #*********************************************************************#
+        sock = self._get_socket_for_felix_peer(hostname)
+        if not sock:
+            LOG.info("No connection to this host, bail out")
+            return
+
+        #*********************************************************************#
+        #* Prepare the fields that are common to all ENDPOINT* requests.     *#
+        #*********************************************************************#
+        rq = {'type': 'ENDPOINT%s' % op,
+              'endpoint_id': port['id'],
+              'issued': time.time() * 1000}
+
+        #*********************************************************************#
+        #* Add the fields that are common to ENDPOINTCREATED and             *#
+        #* ENDPOINTUPDATED.                                                  *#
+        #*********************************************************************#
+        if op == 'CREATED' or op == 'UPDATED':
+            rq.update(
+                {'addrs': [{'addr': ip['ip_address'],
+                            'gateway': self._get_subnet_gw(ip['subnet_id']),
+                            'properties': {'gr': False}}
+                           for ip in port['fixed_ips']],
+                 'mac': port['mac_address'],
+                 'state': 'enabled' if port['admin_state_up'] else 'disabled'}
+            )
+
+        #*********************************************************************#
+        #* For ENDPOINTCREATED, add in the resync_id.  For ENDPOINTUPDATED   *#
+        #* verify that our caller didn't specify any resync_id, as it isn't  *#
+        #* allowed in that case.                                             *#
+        #*********************************************************************#
+        if op == 'CREATED':
+            rq.update({'resync_id': resync_id})
+        else:
+            assert not resync_id
+
+        #*********************************************************************#
+        #* Log the prepared request.                                         *#
+        #*********************************************************************#
+        LOG.info("Prepared request: %s" % rq)
+
+        #*********************************************************************#
+        #* Send the request.  Don't allow this to block - if it does, an     *#
+        #* exception will be thrown.                                         *#
+        #*********************************************************************#
+        try:
+            sock.send_json(rq, zmq.NOBLOCK)
+            LOG.info("Request sent")
+        except:
+            LOG.exception("Exception sending ENDPOINT* request to Felix")
+            self._clear_socket_to_felix_peer(hostname)
+            return
+
+        #*********************************************************************#
+        #* Receive and log Felix's response.  Use poll and NOBLOCK to        *#
+        #* require that this comes within ENDPOINT_RESPONSE_TIMEOUT          *#
+        #* milliseconds.  An exception will be thrown if there's no response *#
+        #* in the allowed time.                                              *#
+        #*********************************************************************#
+        try:
+            sock.poll(ENDPOINT_RESPONSE_TIMEOUT)
+            rsp = sock.recv_json(zmq.NOBLOCK)
+            if rsp['rc'] == 'SUCCESS':
+                LOG.info("Response: %s" % rsp)
+            else:
+                LOG.error("Response: %s" % rsp)
+        except:
+            LOG.exception("Exception receiving ENDPOINT* response from Felix")
+            self._clear_socket_to_felix_peer(hostname)
+            return
+
+    def _get_subnet_gw(self, subnet_id):
+        assert self.db
+        assert self.db_context
+        subnet = self.db.get_subnet(self.db_context, subnet_id)
+        return subnet['gateway_ip']
+
+    def create_network_postcommit(self, context):
+        LOG.info("CREATE_NETWORK_POSTCOMMIT: %s" % context)
+
+    def update_network_postcommit(self, context):
+        LOG.info("UPDATE_NETWORK_POSTCOMMIT: %s" % context)
+
+    def delete_network_postcommit(self, context):
+        LOG.info("DELETE_NETWORK_POSTCOMMIT: %s" % context)
+
+    def create_subnet_postcommit(self, context):
+        LOG.info("CREATE_SUBNET_POSTCOMMIT: %s" % context)
+
+    def update_subnet_postcommit(self, context):
+        LOG.info("UPDATE_SUBNET_POSTCOMMIT: %s" % context)
+
+    def delete_subnet_postcommit(self, context):
+        LOG.info("DELETE_SUBNET_POSTCOMMIT: %s" % context)
+
+    def create_port_postcommit(self, context):
+        LOG.info("CREATE_PORT_POSTCOMMIT: %s" % context)
+        port = context._port
+        if self._port_is_endpoint_port(port):
+            LOG.info("Created port: %s" % port)
+            self.send_endpoint(port['binding:host_id'], None, port, 'CREATED')
+            self._get_db_context()
+            self.db.update_port_status(self.db_context,
+                                       port['id'],
+                                       constants.PORT_STATUS_ACTIVE)
+
+    def update_port_postcommit(self, context):
+        LOG.info("UPDATE_PORT_POSTCOMMIT: %s" % context)
+        port = context._port
+        if self._port_is_endpoint_port(port):
+            LOG.info("Updated port: %s" % port)
+            self.send_endpoint(port['binding:host_id'], None, port, 'UPDATED')
+
+    def delete_port_postcommit(self, context):
+        LOG.info("DELETE_PORT_POSTCOMMIT: %s" % context)
+        port = context._port
+        if self._port_is_endpoint_port(port):
+            LOG.info("Deleted port: %s" % port)
+            self.send_endpoint(port['binding:host_id'],
+                               None,
+                               port,
+                               'DESTROYED')
+
+    def felix_heartbeat_thread(self, hostname):
+
+        while True:
+
+            #*****************************************************************#
+            #* Sleep until time for next heartbeat.                          *#
+            #*****************************************************************#
+            LOG.info("Felix-HEARTBEAT [%s]: sleep until next heartbeat"
+                     % hostname)
+            eventlet.sleep(HEARTBEAT_SEND_INTERVAL_SECS)
+
+            #*****************************************************************#
+            #* Check that there is still a socket to this Felix.             *#
+            #*****************************************************************#
+            sock = self._get_socket_for_felix_peer(hostname)
+            if not sock:
+                LOG.info("No connection to this host, bail out")
+                return
+
+            #*****************************************************************#
+            #* Send a heartbeat.                                             *#
+            #*****************************************************************#
+            try:
+                sock.send_json({'type': 'HEARTBEAT'}, zmq.NOBLOCK)
+                LOG.info("Heartbeat sent")
+            except:
+                LOG.exception("Exception sending ENDPOINT* request to Felix")
+                self._clear_socket_to_felix_peer(hostname)
+                return
+
+            #*****************************************************************#
+            #* Receive and log Felix's response.  Use poll and NOBLOCK to    *#
+            #* require that this comes within HEARTBEAT_RESPONSE_TIMEOUT     *#
+            #* milliseconds.  An exception will be thrown if there's no      *#
+            #* response in the allowed time.                                 *#
+            #*****************************************************************#
+            try:
+                sock.poll(HEARTBEAT_RESPONSE_TIMEOUT)
+                rsp = sock.recv_json(zmq.NOBLOCK)
+                if rsp['type'] == 'HEARTBEAT':
+                    LOG.info("Heartbeat response: %s" % rsp)
+                else:
+                    LOG.error("Unexpected response: %s" % rsp)
+            except:
+                LOG.exception("Exception receiving heartbeat from Felix")
+                self._clear_socket_to_felix_peer(hostname)
+                return
+
+            #*****************************************************************#
+            #* Felix is still there, tell OpenStack.                         *#
+            #*****************************************************************#
+            self.db.create_or_update_agent(self.db_context,
+                                           {'agent_type': AGENT_TYPE_FELIX,
+                                            'binary': '',
+                                            'host': hostname,
+                                            'topic': constants.L2_AGENT_TOPIC})
+
+    def acl_get_thread(self):
+
+        while True:
+
+            LOG.info("ACL-GET: wait to receive next message")
+            try:
+                #*************************************************************#
+                #* Receive the next message on the ROUTER socket for ACL     *#
+                #* Managers.  This may block, but that's OK because all      *#
+                #* other green threads in the Neutron server process can run *#
+                #* in the meantime.                                          *#
+                #*************************************************************#
+                message = self.acl_get_socket.recv_multipart()
+
+                #*************************************************************#
+                #* Every message on this socket should be multipart with 3   *#
+                #* parts, of which the second part is always empty.  (Why?)  *#
+                #*************************************************************#
+                assert (len(message) == 3)
+                assert not message[1]
+
+                #*************************************************************#
+                #* The first part is the connection identity, and the third  *#
+                #* is the message content.                                   *#
+                #*************************************************************#
+                peer = message[0]
+                rq = json.loads(message[2].decode('utf-8'))
+                LOG.info("ACL-GET RX [%s] %s" % (peer, rq))
+
+                if rq['type'] == 'GETGROUPS':
+                    #*********************************************************#
+                    #* It's a GETGROUPS request.                             *#
+                    #*********************************************************#
+                    LOG.info("GETGROUPS request")
+
+                    #*********************************************************#
+                    #* Send a GETGROUPS response, with no detail, on the     *#
+                    #* ROUTER socket.                                        *#
+                    #*********************************************************#
+                    rsp = {'type': 'GETGROUPS'}
+                    LOG.info("Sending GETGROUPS response: %s" % rsp)
+                    self.acl_get_socket.send_multipart(
+                        [peer,
+                         '',
+                         json.dumps(rsp).encode('utf-8')])
+
+                    #*********************************************************#
+                    #* Set up access to the Neutron database, if we haven't  *#
+                    #* already.                                              *#
+                    #*********************************************************#
+                    self._get_db_context()
+
+                    #*********************************************************#
+                    #* Get a list of all security groups.                    *#
+                    #*********************************************************#
+                    LOG.info("Query Neutron DB...")
+                    sgs = self.db.get_security_groups(self.db_context)
+
+                    #*********************************************************#
+                    #* Send a GROUPUPDATE message for each group.            *#
+                    #*********************************************************#
+                    for sg in sgs:
+                        self.send_group(sg)
+
+                elif rq['type'] == 'HEARTBEAT':
+                    #*********************************************************#
+                    #* It's a heartbeat.  Send the same back.                *#
+                    #*********************************************************#
+                    LOG.info("HEARTBEAT")
+                    self.acl_get_socket.send_multipart(
+                        peer,
+                        '',
+                        json.dumps(rq).encode('utf-8'))
+
+                else:
+                    #*********************************************************#
+                    #* It's something unexpected.  Log a warning, but send   *#
+                    #* it back anyway.                                       *#
+                    #*********************************************************#
+                    LOG.warn("Unexpected request type")
+                    self.acl_get_socket.send_multipart(
+                        peer,
+                        '',
+                        json.dumps(rq).encode('utf-8'))
+            except:
+                LOG.exception("Exception in ACL Manager-facing ROUTER thread")
+
+    def send_group(self, sg):
+        LOG.info("Publish definition of security group %s" % sg)
+
+        #*********************************************************************#
+        #* Send a GROUPUPDATE message, with the definition of this security  *#
+        #* group, on the PUB socket.                                         *#
+        #*********************************************************************#
+        [inbound, outbound] = self._get_rules(sg)
+        pub = {'type': 'GROUPUPDATE',
+               'group': sg['id'],
+               'rules': {'inbound': inbound,
+                         'outbound': outbound,
+                         'inbound_default': 'deny',
+                         'outbound_default': 'deny'},
+               'members': self._get_members(sg),
+               'issued': time.time() * 1000}
+        LOG.info("Sending GROUPUPDATE: %s" % pub)
+
+        self.acl_pub_socket.send_multipart(['groups'.encode('utf-8'),
+                                            json.dumps(pub).encode('utf-8')])
+        LOG.info("Message sent")
+
+    def _get_rules(self, sg):
+        inbound = []
+        outbound = []
+        for rule in sg['security_group_rules']:
+            LOG.info("Neutron rule %s" % rule)
+
+            #*****************************************************************#
+            #* Map the straightforward fields from Neutron to Calico format. *#
+            #*****************************************************************#
+            api_rule = {'group': rule['remote_group_id'],
+                        'cidr': rule['remote_ip_prefix'],
+                        'protocol': rule['protocol']}
+
+            #*****************************************************************#
+            #* OpenStack (sometimes) represents 'any IP address' by setting  *#
+            #* both 'remote_group_id' and 'remote_ip_prefix' to None.  For   *#
+            #* the Calico Network API we must represent that as an explicit  *#
+            #* 0.0.0.0/0 (for IPv4) or ::/0 (for IPv6).                      *#
+            #*****************************************************************#
+            if not (api_rule['group'] or api_rule['cidr']):
+                api_rule['cidr'] = {'IPv4': '0.0.0.0/0',
+                                    'IPv6': '::/0'}[rule['ethertype']]
+
+            #*****************************************************************#
+            #* The 'port' field can be '*', or a single number, or a range.  *#
+            #*****************************************************************#
+            if rule['port_range_min'] == -1:
+                api_rule['port'] = '*'
+            elif rule['port_range_min'] == rule['port_range_max']:
+                api_rule['port'] = rule['port_range_min']
+            else:
+                api_rule['port'] = [rule['port_range_min'],
+                                    rule['port_range_max']]
+
+            #*****************************************************************#
+            #* Add to either the inbound or outbound list, according to      *#
+            #* Neutron's 'direction' field.                                  *#
+            #*****************************************************************#
+            if rule['direction'] == 'ingress':
+                LOG.info("=> Inbound Calico rule %s" % api_rule)
+                inbound.append(api_rule)
+            else:
+                LOG.info("=> Outbound Calico rule %s" % api_rule)
+                outbound.append(api_rule)
+
+        return [inbound, outbound]
+
+    def _get_members(self, sg):
+        filters = {'security_group_id': [sg['id']]}
+        bindings = self.db._get_port_security_group_bindings(self.db_context,
+                                                             filters)
+        endpoints = {}
+        for binding in bindings:
+            port_id = binding['port_id']
+            port = self.db.get_port(self.db_context, port_id)
+            endpoints[port_id] = [ip['ip_address'] for ip in port['fixed_ips']]
+
+        LOG.info("Endpoints for SG %s are %s" % (sg['id'], endpoints))
+        return endpoints
+
+    def send_sg_updates(self, sgids):
+        for sgid in sgids:
+            self.send_group(self.db.get_security_group(self.db_context, sgid))
+
+
+class CalicoNotifierProxy(object):
+    """Proxy pattern class used to intercept security-related notifications
+    from the ML2 plugin.
+    """
+
+    def __init__(self, ml2_notifier, calico_driver):
+        self.ml2_notifier = ml2_notifier
+        self.calico_driver = calico_driver
+
+    def __getattr__(self, name):
+        return getattr(self.ml2_notifier, name)
+
+    def security_groups_rule_updated(self, context, sgids):
+        LOG.info("security_groups_rule_updated: %s %s" % (context, sgids))
+        self.calico_driver.send_sg_updates(sgids)
+        self.ml2_notifier.security_groups_rule_updated(context, sgids)
+
+    def security_groups_member_updated(self, context, sgids):
+        LOG.info("security_groups_member_updated: %s %s" % (context, sgids))
+        self.calico_driver.send_sg_updates(sgids)
+        self.ml2_notifier.security_groups_member_updated(context, sgids)
--- a/neutron/plugins/ml2/rpc.py
+++ b/neutron/plugins/ml2/rpc.py
@@ -150,7 +150,11 @@
                      'admin_state_up': port.admin_state_up,
                      'network_type': segment[api.NETWORK_TYPE],
                      'segmentation_id': segment[api.SEGMENTATION_ID],
-                     'physical_network': segment[api.PHYSICAL_NETWORK]}
+                     'physical_network': segment[api.PHYSICAL_NETWORK],
+                     'fixed_ips': [{'subnet_id': ip["subnet_id"],
+                                    'ip_address': ip["ip_address"]}
+                                   for ip in port["fixed_ips"]],
+                     'mac_address': port.mac_address}
             LOG.debug(_("Returning: %s"), entry)
             return entry
 
--- a/neutron/tests/unit/test_dhcp_agent.py
+++ b/neutron/tests/unit/test_dhcp_agent.py
@@ -223,11 +223,11 @@
         network.id = '1'
         dhcp = dhcp_agent.DhcpAgent(cfg.CONF)
         self.assertTrue(dhcp.call_driver('foo', network))
-        self.driver.assert_called_once_with(cfg.CONF,
-                                            mock.ANY,
-                                            'sudo',
-                                            mock.ANY,
-                                            mock.ANY)
+        self.driver.assert_has_calls([mock.call(cfg.CONF,
+                                                mock.ANY,
+                                                'sudo',
+                                                mock.ANY,
+                                                mock.ANY)])
 
     def _test_call_driver_failure(self, exc=None,
                                   trace_level='exception', expected_sync=True):
@@ -237,11 +237,11 @@
         with mock.patch.object(dhcp_agent.LOG, trace_level) as log:
             dhcp = dhcp_agent.DhcpAgent(HOSTNAME)
             self.assertIsNone(dhcp.call_driver('foo', network))
-            self.driver.assert_called_once_with(cfg.CONF,
-                                                mock.ANY,
-                                                'sudo',
-                                                mock.ANY,
-                                                mock.ANY)
+            self.driver.assert_has_calls([mock.call(cfg.CONF,
+                                                    mock.ANY,
+                                                    'sudo',
+                                                    mock.ANY,
+                                                    mock.ANY)])
             self.assertEqual(log.call_count, 1)
             self.assertEqual(expected_sync, dhcp.needs_resync)
 
@@ -1161,6 +1161,7 @@
         self.mock_iproute = mock.MagicMock()
         driver_cls.return_value = self.mock_driver
         iproute_cls.return_value = self.mock_iproute
+        self.mock_driver.bridged.return_value = True
 
     def tearDown(self):
         self.dvr_cls_p.stop()
@@ -1194,6 +1195,7 @@
 
         expected_ips = ['172.9.9.9/24', '169.254.169.254/16']
         expected = [
+            mock.call.bridged(),
             mock.call.get_device_name(port),
             mock.call.init_l3(
                 'tap12345678-12',
@@ -1201,7 +1203,7 @@
                 namespace=net.namespace)]
 
         if not reuse_existing:
-            expected.insert(1,
+            expected.insert(2,
                             mock.call.plug(net.id,
                                            port.id,
                                            'tap12345678-12',
--- a/neutron/tests/unit/test_metadata_namespace_proxy.py
+++ b/neutron/tests/unit/test_metadata_namespace_proxy.py
@@ -330,7 +330,8 @@
                             daemon.assert_has_calls([
                                 mock.call('pidfile', 9697,
                                           router_id='router_id',
-                                          network_id=None),
+                                          network_id=None,
+                                          flat=mock.ANY),
                                 mock.call().start()]
                             )
 
@@ -353,6 +354,7 @@
                             daemon.assert_has_calls([
                                 mock.call('pidfile', 9697,
                                           router_id='router_id',
-                                          network_id=None),
+                                          network_id=None,
+                                          flat=mock.ANY),
                                 mock.call().run()]
                             )
--- a/setup.cfg
+++ b/setup.cfg
@@ -190,6 +190,7 @@
 	ofagent = neutron.plugins.ml2.drivers.mech_ofagent:OfagentMechanismDriver
 	mlnx = neutron.plugins.ml2.drivers.mlnx.mech_mlnx:MlnxMechanismDriver
 	brocade = neutron.plugins.ml2.drivers.brocade.mechanism_brocade:BrocadeMechanism
+	calico = neutron.plugins.ml2.drivers.mech_calico:CalicoMechanismDriver
 neutron.openstack.common.cache.backends = 
 	memory = neutron.openstack.common.cache._backends.memory:MemoryBackend
 
--- a/neutron.egg-info/SOURCES.txt
+++ b/neutron.egg-info/SOURCES.txt
@@ -754,6 +754,7 @@
 neutron/plugins/ml2/drivers/README.odl
 neutron/plugins/ml2/drivers/__init__.py
 neutron/plugins/ml2/drivers/mech_agent.py
+neutron/plugins/ml2/drivers/mech_calico.py
 neutron/plugins/ml2/drivers/mech_hyperv.py
 neutron/plugins/ml2/drivers/mech_linuxbridge.py
 neutron/plugins/ml2/drivers/mech_ofagent.py
@@ -1463,4 +1464,4 @@
 tools/i18n_cfg.py
 tools/install_venv.py
 tools/install_venv_common.py
-tools/with_venv.sh
\ No newline at end of file
+tools/with_venv.sh
--- a/neutron.egg-info/entry_points.txt
+++ b/neutron.egg-info/entry_points.txt
@@ -74,6 +74,7 @@
 bigswitch = neutron.plugins.ml2.drivers.mech_bigswitch.driver:BigSwitchMechanismDriver
 brocade = neutron.plugins.ml2.drivers.brocade.mechanism_brocade:BrocadeMechanism
 bulkless = neutron.tests.unit.ml2.drivers.mechanism_bulkless:BulklessMechanismDriver
+calico = neutron.plugins.ml2.drivers.mech_calico:CalicoMechanismDriver
 cisco_nexus = neutron.plugins.ml2.drivers.cisco.nexus.mech_cisco_nexus:CiscoNexusMechanismDriver
 hyperv = neutron.plugins.ml2.drivers.mech_hyperv:HypervMechanismDriver
 l2population = neutron.plugins.ml2.drivers.l2pop.mech_driver:L2populationMechanismDriver
--- a/neutron/tests/unit/test_metadata_agent.py
+++ b/neutron/tests/unit/test_metadata_agent.py
@@ -198,7 +198,15 @@
         self.assertEqual(expected, ports)
 
     def test_get_ports_no_id(self):
-        self.assertRaises(TypeError, self.handler._get_ports, 'remote_address')
+        remote_address = 'remote-address'
+        expected = ['port1']
+        with contextlib.nested(
+            mock.patch.object(self.handler, '_get_ports_for_remote_address'),
+        ) as (mock_get_ip_addr):
+            mock_get_ip_addr[0].return_value = expected
+            ports = self.handler._get_ports(remote_address)
+            mock_get_ip_addr[0].assert_called_once_with(remote_address, None)
+        self.assertEqual(expected, ports)
 
     def _get_instance_and_tenant_id_helper(self, headers, list_ports_retval,
                                            networks=None, router_id=None):
